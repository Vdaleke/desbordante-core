#include "fdhits.h"

#include <chrono>
#include <utility>
#include <vector>

#include <easylogging++.h>

#include "algorithms/fd/fdhits/config.h"
#include "algorithms/fd/fdhits/hypergraph.h"
#include "algorithms/fd/fdhits/pli_table.h"
#include "algorithms/fd/fdhits/result_collector.h"
#include "algorithms/fd/fdhits/tree_search.h"
#include "algorithms/fd/hycommon/preprocessor.h"
#include "algorithms/fd/hycommon/types.h"
#include "config/thread_number/option.h"
#include "model/table/column_combination.h"
#include "model/table/position_list_index.h"
#include "model/table/relational_schema.h"
#include "model/table/vertical.h"

namespace algos::fdhits {

fdhits::FdHits::FdHits() : algos::PliBasedFDAlgorithm({kDefaultPhaseName}, std::nullopt), number_of_threads_(1) {
    RegisterOption(config::kThreadNumberOpt(&number_of_threads_));
}

fdhits::PLITable FdHits::Preprocess(fdhits::ResultCollector& rc) {
    rc.StartTimer(fdhits::timer::TimerName::CONSTRUCT_CLUSTERS);

    fdhits::PLITable tab;

    // Проверяем, что relation_ проинициализирован
    if (!relation_) {
        LOG(ERROR) << "Relation data is not initialized.";
        rc.StopTimer(fdhits::timer::TimerName::CONSTRUCT_CLUSTERS);
        return tab;
    }

    tab.nr_rows = relation_->GetNumRows();
    tab.nr_cols = relation_->GetNumColumns();

    model::ColumnIndex const num_columns = relation_->GetNumColumns();
    auto plis = algos::hy::util::BuildPLIs(relation_.get());
    for (model::ColumnIndex column_index = 0; column_index < num_columns; column_index++) {
        if (plis[column_index]) {  // Проверяем, что указатель не nullptr
            auto const& index = plis[column_index]->GetIndex();
            tab.plis.push_back(index);
        } else {
            LOG(ERROR) << "Null PLI for column " << column_index;
            // Добавляем пустой индекс
            tab.plis.push_back({});
        }
    }
    
    // Получаем инвертированное представление PLI
    tab.inverse_mapping = algos::hy::util::BuildInvertedPlis(plis);
    
    // Подготовка PLI в соответствии с Rust-кодом:
    // Кластер с индексом 0 означает синглтонный элемент
    // (элемент, который не входит ни в один кластер эквивалентности)
    for (model::ColumnIndex col = 0; col < tab.nr_cols; col++) {
        if (col < tab.inverse_mapping.size()) {
            // Сначала все элементы помечаются как синглтонные (индекс 0)
            std::vector<unsigned> new_mapping(tab.nr_rows, 0);
            
            // Затем для каждого кластера устанавливаем номер кластера + 1
            // (чтобы оставить 0 для синглтонных элементов)
            for (size_t cluster_idx = 0; cluster_idx < tab.plis[col].size(); cluster_idx++) {
                for (auto row_idx : tab.plis[col][cluster_idx]) {
                    if (static_cast<size_t>(row_idx) < new_mapping.size()) {
                        new_mapping[row_idx] = cluster_idx + 1;
                    }
                }
            }
            
            tab.inverse_mapping[col] = std::move(new_mapping);
        }
    }

    rc.StopTimer(fdhits::timer::TimerName::CONSTRUCT_CLUSTERS);
    return tab;
}

void FdHits::MakeExecuteOptsAvailableFDInternal() {
    // Добавляем свои опции
    MakeOptionsAvailable({::config::kThreadNumberOpt.GetName()});
}

void FdHits::ResetStateFd() {
    // Сбрасываем состояние перед запуском алгоритма
    fd_collection_.Clear();
}

// Метод для валидации FD-кандидатов - проверяет выполняется ли FD: lhs → rhs
bool ValidateFD(PLITable const& tab, Edge const& lhs, model::ColumnIndex rhs) {
    // Проверяем валидность входных данных
    if (rhs >= tab.nr_cols) {
        return false;  // Невалидный индекс RHS
    }

    if (lhs.size() != tab.nr_cols) {
        return false;  // Размер LHS не соответствует числу колонок
    }

    // Проверяем валидность inverse_mapping
    if (tab.inverse_mapping.size() <= rhs || tab.plis.size() <= rhs) {
        return false;  // Не хватает данных для RHS
    }
    
    // Проверяем валидность inverse_mapping
    if (tab.inverse_mapping.size() <= rhs || tab.plis.size() <= rhs) {
        return false;  // Не хватает данных для RHS
    }

    // Если LHS пустой, проверяем, является ли RHS константным или имеет только один кластер
    if (lhs.none()) {
        // Для пустого LHS проверяем количество неодиночных кластеров в RHS
        // (кластеры с индексом 0 считаются одиночными в нашем коде)
        size_t non_singleton_clusters = 0;
        for (const auto& cluster : tab.plis[rhs]) {
            if (cluster.size() >= 2) {
                non_singleton_clusters++;
            }
        }
        return non_singleton_clusters <= 1;
    }

    // Если LHS пустой, то проверяем, является ли RHS константным
    if (lhs.none()) {
        // Для пустого LHS проверяем количество неодиночных кластеров в RHS
        // (кластеры с индексом 0 считаются одиночными в Rust-коде)
        size_t non_singleton_clusters = 0;
        for (const auto& cluster : tab.plis[rhs]) {
            if (cluster.size() >= 2) {
                non_singleton_clusters++;
            }
        }
        return non_singleton_clusters <= 1;
    }

    // Для каждой пары строк
    for (unsigned long i = 0; i < tab.nr_rows; i++) {
        for (unsigned long j = i + 1; j < tab.nr_rows; j++) {
            // Проверяем, эквивалентны ли строки i и j по всем столбцам из LHS
            bool equal_on_lhs = true;

            for (unsigned int col = 0; col < tab.nr_cols; col++) {
                if (lhs[col]) {
                    // Проверяем, что у нас есть данные для этого столбца
                    if (col >= tab.inverse_mapping.size()) {
                        equal_on_lhs = false;
                        break;
                    }
                    
                    // Проверяем, что индексы строк валидны
                    if (i >= tab.inverse_mapping[col].size() || j >= tab.inverse_mapping[col].size()) {
                        equal_on_lhs = false;
                        break;
                    }
                    
                    // Получаем кластеры для строк i и j в столбце col
                    unsigned cluster_i = tab.inverse_mapping[col][i];
                    unsigned cluster_j = tab.inverse_mapping[col][j];

                    // В Rust-коде кластер с индексом 0 считается особым (синглтонным)
                    // Строки эквивалентны, если они в одном кластере И кластер не 0
                    if (cluster_i != cluster_j || cluster_i == 0 || cluster_j == 0) {
                        equal_on_lhs = false;
                        break;
                    }
                }
            }

            // Если строки эквивалентны по LHS, проверяем их эквивалентность по RHS
            if (equal_on_lhs) {
                // Проверяем границы доступа
                if (i >= tab.inverse_mapping[rhs].size() || j >= tab.inverse_mapping[rhs].size()) {
                    return false;
                }
                
                unsigned cluster_i_rhs = tab.inverse_mapping[rhs][i];
                unsigned cluster_j_rhs = tab.inverse_mapping[rhs][j];

                // Строки в RHS должны быть в одном кластере, и кластер не должен быть 0
                if (cluster_i_rhs != cluster_j_rhs || cluster_i_rhs == 0 || cluster_j_rhs == 0) {
                    return false;
                }
            }
        }
    }

    // Если не нашли контрпример, то LHS → RHS является функциональной зависимостью
    return true;
}

void FdHits::RegisterFDs(fdhits::ResultCollector const& rc) {
    // Проверяем, что relation_ не nullptr
    if (!relation_) {
        LOG(ERROR) << "Relation data is not initialized in RegisterFDs";
        return;
    }
    
    auto schema_ptr = relation_->GetSchema();
    
    // Проверяем, что схема не пустая
    if (!schema_ptr) {
        LOG(ERROR) << "Schema is null in RegisterFDs";
        return;
    }

    for (auto const& fd_pair : rc.GetFDs()) {
        try {
            // Извлекаем индексы колонок LHS и RHS
            auto lhs_indices = fd_pair.first.GetColumnIndices();
            model::ColumnIndex rhs_idx = fd_pair.second;

            // Проверяем, что RHS индекс находится в пределах таблицы
            if (rhs_idx >= relation_->GetNumColumns()) {
                LOG(WARNING) << "Skipping FD with invalid RHS column index: " << rhs_idx;
                continue;
            }

            // Получаем колонку RHS
            Column const* rhs_column = schema_ptr->GetColumn(rhs_idx);

            // Создаем колонки из LHS
            std::vector<Column const*> left_columns;
            for (auto idx : lhs_indices) {
                if (idx < relation_->GetNumColumns()) {
                    left_columns.push_back(schema_ptr->GetColumn(idx));
                } else {
                    LOG(WARNING) << "Invalid column index in LHS: " << idx << ", skipping this FD";
                    continue;
                }
            }

            // Обрабатываем случай пустого LHS
            if (left_columns.empty()) {
                // Для пустого LHS, создаем пустой вертикал
                auto empty_lhs = Vertical::EmptyVertical(schema_ptr);
                Column rhs_col(*rhs_column);
                FDAlgorithm::RegisterFd(std::move(*empty_lhs), std::move(rhs_col),
                                        relation_->GetSharedPtrSchema());
                continue;
            }

            // Начинаем с первой колонки
            Vertical lhs_vertical(*left_columns[0]);

            // Добавляем остальные колонки через Union
            for (size_t i = 1; i < left_columns.size(); i++) {
                lhs_vertical = lhs_vertical.Union(*left_columns[i]);
            }

            // Создаем Column для RHS
            Column rhs_col(*rhs_column);

            // Используем метод RegisterFd базового класса
            FDAlgorithm::RegisterFd(std::move(lhs_vertical), std::move(rhs_col),
                                    relation_->GetSharedPtrSchema());
        } catch (std::exception const& e) {
            LOG(ERROR) << "Error registering FD: " << e.what();
        }
    }
}

void FdHits::PrintInfo(fdhits::ResultCollector const& rc) const {
    LOG(INFO) << "FD-HITS algorithm execution completed";
    LOG(INFO) << "Total time: " << rc.GetTimeFor(fdhits::timer::TimerName::TOTAL) << " s";
    LOG(INFO) << "Preprocessing time: "
              << rc.GetTimeFor(fdhits::timer::TimerName::CONSTRUCT_CLUSTERS) << " s";
    LOG(INFO) << "Hitting set time: " << rc.GetTimeFor(fdhits::timer::TimerName::HITTING_SET)
              << " s";
    LOG(INFO) << "Validation time: " << rc.GetTimeFor(fdhits::timer::TimerName::VALIDATE) << " s";
    LOG(INFO) << "Candidates checked: " << rc.GetCandidatesChecked();
    LOG(INFO) << "FDs found: " << rc.GetFDsFound();
    LOG(INFO) << "HASH: " << Fletcher16();
}

unsigned int FdHits::Fletcher16() const {
    // Реализуем алгоритм Fletcher-16 для расчета контрольной суммы
    // https://en.wikipedia.org/wiki/Fletcher%27s_checksum

    // Берем все найденные ФЗ и создаем из них массив байт
    std::vector<unsigned char> data;

    // Для каждой ФЗ добавляем индексы колонок
    for (auto const& fd : fd_collection_.AsList()) {
        // LHS
        auto lhs_indices = fd.GetLhs().GetColumnIndicesAsVector();
        for (auto idx : lhs_indices) {
            data.push_back(static_cast<unsigned char>(idx & 0xFF));
            data.push_back(static_cast<unsigned char>((idx >> 8) & 0xFF));
        }
        data.push_back(0xFF);  // Разделитель между LHS и RHS

        // RHS
        auto rhs_idx = fd.GetRhs().GetIndex();
        data.push_back(static_cast<unsigned char>(rhs_idx & 0xFF));
        data.push_back(static_cast<unsigned char>((rhs_idx >> 8) & 0xFF));
        data.push_back(0xFE);  // Разделитель между разными ФЗ
    }

    // Применяем алгоритм Fletcher-16
    unsigned short sum1 = 0;
    unsigned short sum2 = 0;

    for (auto byte : data) {
        sum1 = (sum1 + byte) % 255;
        sum2 = (sum2 + sum1) % 255;
    }

    return (sum2 << 8) | sum1;
}

unsigned long long FdHits::ExecuteInternal() {
    LOG(INFO) << "Starting FD-HITS algorithm execution";

    // Проверяем, загружены ли данные
    if (!relation_) {
        LOG(ERROR) << "Data is not loaded. Call LoadData() first.";
        return 0;
    }

    // Проверяем, что данные не пустые
    if (relation_->GetNumRows() == 0 || relation_->GetNumColumns() == 0) {
        LOG(WARNING) << "Dataset is empty (0 rows or 0 columns). Skipping execution.";
        return 0;
    }

    try {
        // Настраиваем конфигурацию алгоритма
        fdhits::Config cfg;
        cfg.timeout = 3600;  // 1 hour
        cfg.threads = number_of_threads_;
        cfg.sample_size = 2000;  // Существенно увеличиваем размер выборки для hitting set для обнаружения большего количества FDs

        // Инициализируем сборщик результатов и запускаем таймер
        fdhits::ResultCollector rc(cfg.timeout);
        rc.StartTimer(fdhits::timer::TimerName::TOTAL);
        auto start_time = std::chrono::system_clock::now();

        // Предварительная обработка - создаем PLI таблицу
        fdhits::PLITable tab = Preprocess(rc);

        // Проверяем, не пустая ли таблица
        if (tab.nr_rows == 0 || tab.nr_cols == 0) {
            LOG(WARNING) << "Empty table, skipping FD-HITS execution";
            return 0;
        }

        // Основной алгоритм FD-HITS

        // Шаг 1: Генерируем кандидатов FD с помощью TreeSearch
        rc.StartTimer(fdhits::timer::TimerName::HITTING_SET);

        // Создаем объект TreeSearch для поиска минимальных hitting sets
        fdhits::TreeSearch ts(tab, cfg, rc);

        // Получаем минимальные hitting sets (кандидаты LHS)
        std::vector<fdhits::Edge> candidates = ts.ComputeMinimalHittingSets();

        rc.StopTimer(fdhits::timer::TimerName::HITTING_SET);

        // Шаг 2: Валидация кандидатов
        rc.StartTimer(fdhits::timer::TimerName::VALIDATE);

        // Создаем дополнительных кандидатов для проверки
        std::vector<fdhits::Edge> extra_candidates;
        
        // Для небольших таблиц генерируем все возможные комбинации 1 и 2 колонок
        if (tab.nr_cols <= 20) {  // Ограничиваем для больших таблиц
            // Добавляем кандидатов из одиночных колонок
            for (model::ColumnIndex col = 0; col < tab.nr_cols; col++) {
                fdhits::Edge single_col(tab.nr_cols);
                single_col[col] = true;
                extra_candidates.push_back(single_col);
            }
            
            // Добавляем кандидатов из пар колонок
            for (model::ColumnIndex col1 = 0; col1 < tab.nr_cols; col1++) {
                for (model::ColumnIndex col2 = col1 + 1; col2 < tab.nr_cols; col2++) {
                    fdhits::Edge two_cols(tab.nr_cols);
                    two_cols[col1] = true;
                    two_cols[col2] = true;
                    extra_candidates.push_back(two_cols);
                }
            }
        }
        
        // Объединяем основных и дополнительных кандидатов
        candidates.insert(candidates.end(), extra_candidates.begin(), extra_candidates.end());
        
        // Удаляем дубликаты
        std::sort(candidates.begin(), candidates.end());
        candidates.erase(std::unique(candidates.begin(), candidates.end()), candidates.end());

        // Для каждого потенциального LHS и для каждого столбца RHS
        for (auto const& lhs : candidates) {
            for (model::ColumnIndex rhs = 0; rhs < tab.nr_cols; rhs++) {
                // Пропускаем случаи, когда столбец RHS уже включен в LHS
                if (lhs[rhs]) {
                    continue;
                }

                // Регистрируем кандидата
                rc.RegisterCandidate();

                // Проверяем, является ли LHS -> RHS функциональной зависимостью
                if (fdhits::ValidateFD(tab, lhs, rhs)) {
                    // Подготавливаем LHS колонки
                    std::vector<model::ColumnIndex> lhs_indices;
                    for (size_t i = 0; i < lhs.size(); i++) {
                        if (lhs[i]) {
                            lhs_indices.push_back(static_cast<model::ColumnIndex>(i));
                        }
                    }

                    // Создаем ColumnCombination для LHS
                    ::model::ColumnCombination lhs_cc(0, lhs_indices);  // 0 - индекс таблицы

                    // Регистрируем FD
                    rc.RegisterFD(lhs_cc, rhs);
                }
            }
        }

        rc.StopTimer(fdhits::timer::TimerName::VALIDATE);
        rc.StopTimer(fdhits::timer::TimerName::TOTAL);

        // Регистрируем найденные FDs в системе
        RegisterFDs(rc);

        auto end_time = std::chrono::system_clock::now();
        unsigned long long execution_time =
                std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time)
                        .count();

        PrintInfo(rc);

        return execution_time;
    } catch (std::exception const& e) {
        // Обрабатываем исключения, чтобы избежать сегментации
        LOG(ERROR) << "FD-HITS algorithm failed with error: " << e.what();
        return 0;
    } catch (...) {
        LOG(ERROR) << "FD-HITS algorithm failed with unknown error";
        return 0;
    }
}

}  // namespace algos::fdhits
